module EratosthenesTest
imports
    from Eratosthenes all,
    from UnitTesting
        operations
            assert: bool * seq of char ==> () renamed assert;
            assertEquals: ? * ? * seq of char ==> () renamed assertEquals;
            assertApproxEquals: real * real * real * seq of char ==> ()
                renamed assertApproxEquals;
            shouldFail: (bool -> ?) * seq of char ==> () renamed shouldFail;
exports all
definitions
operations
    test_pre_createSieve : () ==> ()
    test_pre_createSieve() ==
        (dcl sieve:Eratosthenes`Sieve := mk_Eratosthenes`Sieve([]);
        assert(Eratosthenes`pre_createSieve(2, sieve), "createSieve(2)");
        assert(Eratosthenes`pre_createSieve(3, sieve), "createSieve(3)");
        assert(Eratosthenes`pre_createSieve(100, sieve), "createSieve(100)");
        assert(not Eratosthenes`pre_createSieve(1, sieve), "should not be 1"));
    
    test_isPrime : () ==> ()
    test_isPrime() ==
        (Eratosthenes`isPrime(36);
        if
            false
        then
            assertEquals(#act(Eratosthenes`createSieve), 0, "not created");
        if false then assertEquals(#rd(Eratosthenes`sieve), 0, "no read access");
        if false then assertEquals(#wr(Eratosthenes`sieve), 0, "no write access");
        Eratosthenes`isPrime(37);
        if false then assertEquals(#act(Eratosthenes`createSieve), 1, " created");
        if false then assertEquals(#rd(Eratosthenes`sieve), 2, "2 read access");
        if false then assertEquals(#wr(Eratosthenes`sieve), 1, "1 write access");
        Eratosthenes`isPrime(23);
        if
            false
        then
            assertEquals(#act(Eratosthenes`createSieve), 1, "not created");
        if false then assertEquals(#rd(Eratosthenes`sieve), 4, "2 read access");
        if false then assertEquals(#wr(Eratosthenes`sieve), 1, "no write access");
        skip);
end EratosthenesTest