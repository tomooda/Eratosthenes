module Eratosthenes
exports all
definitions
state Sieve of
    sieve : seq of bool
init s == s = mk_Sieve([])
end
operations
    isPrime : nat1 ==> bool
    isPrime(n) ==
        (if isEven(n) then return n = 2;
        let index = n div 2
        in
            (if index > len sieve then createSieve(n);
            return sieve(index)))
    pre  n >= 2;
    
    createSieve : nat1 ==> ()
    createSieve(size) ==
        (sieve := [true | i in set {1, ..., size div 2 + size mod 2 - 1}];
        (dcl n:nat1 := 3;
        while n  * n <= size
        do
            (if
                sieve(n div 2)
            then
                (for m = n  * 3 to  size by  n  * 2 do sieve(m div 2) := false);
            n := n + 2)))
    pre  size > 1
    post 
        if size mod 2 = 0 then (size - 1) div 2 = len sieve else size div 2 = len sieve;
functions
    isEven : nat1 -> bool
    isEven(n) == n mod 2 = 0;
end Eratosthenes