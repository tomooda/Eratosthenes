module Eratosthenes
exports all
definitions
state Sieve of
    sieve : seq of bool
init s == s = mk_Sieve([])
end
operations
    isPrime : nat1 ==> bool
    isPrime(n) ==
        (if n > len sieve then createSieve(n);
        return sieve(n))
    pre  n >= 2
    post 
        RESULT <=> not (exists p in set {2, ..., n - 1} & n mod p = 0);
    
    createSieve : nat1 ==> ()
    createSieve(size) ==
        (dcl newSieve:seq of bool := [true | i in set {1, ..., size}];
        (dcl n:nat1 := 2;
        newSieve(1) := false;
        while n  * n <= size
        do
            (if newSieve(n) then for m = n  * 2 to  size by  n do newSieve(m) := false;
            n := n + 1));
        sieve := newSieve)
    pre  size >= 2
    post 
        len sieve = size
        and (forall n in set {2, ..., size} &
                sieve(n) <=> not (exists p in set {2, ..., n - 1} & n mod p = 0));
traces
    Singles:
        let n in set {2, ..., 50} in isPrime(n);
    
    Pairs:
        let n1, n2 in set {2, ..., 50}
        in
            (isPrime(n1);
            isPrime(n2));
end Eratosthenes