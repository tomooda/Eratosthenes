module Eratosthenesexports alldefinitionsstate Sieve of    sieve : seq of boolinit s == s = mk_Sieve([])endoperations    createSieve : nat1 ==> ()    createSieve(size) == sieve := [false | i in set {1, ..., size}]    pre  size > 1    post  len sieve = size and (forall b in seq sieve & not b);end Eratosthenesmodule UnitTestingexports alldefinitionstypes    AssertFailure :: msg : seq of char;        AssertEqualsFailure :: actual : ? expected : ? msg : seq of char;operations    assert : bool * seq of char ==> ()    assert(b, msg) == if not b then exit mk_AssertFailure(msg);        assertEquals : ? * ? * seq of char ==> ()    assertEquals(actual, expected, msg) ==        if            actual <> expected        then            exit mk_AssertEqualsFailure(actual, expected, msg);        assertApproxEquals : real * real * real * seq of char ==> ()    assertApproxEquals(actual, expected, accuracy, msg) ==        if            abs (actual - expected) > accuracy        then            exit mk_AssertEqualsFailure(actual, expected, msg);        shouldFail : (bool -> ?) * seq of char ==> ()    shouldFail(f, msg) ==        trap - with skip in let - = f(true) in assert(false, msg);end UnitTestingmodule EratosthenesTestimports    from Eratosthenes all,    from UnitTesting        operations            assert: bool * seq of char ==> () renamed assert;            assertEquals: ? * ? * seq of char ==> () renamed assertEquals;            assertApproxEquals: real * real * real * seq of char ==> ()                renamed assertApproxEquals;            shouldFail: (bool -> bool) * seq of char ==> () renamed shouldFail;exports alldefinitionsoperations    testCreateSieve : () ==> ()    testCreateSieve() ==        (Eratosthenes`createSieve(2);        Eratosthenes`createSieve(3);        Eratosthenes`createSieve(100);        shouldFail(lambda b : bool & Eratosthenes`createSieve(0), "should not be 1"));end EratosthenesTest