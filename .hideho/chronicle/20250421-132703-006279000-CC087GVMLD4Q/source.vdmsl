module Eratosthenesexports alldefinitionsstate Sieve of    sieve : seq of boolinit s == s = mk_Sieve([])endoperations    isPrime : nat1 ==> bool    isPrime(n) ==        (if n > len sieve then createSieve(n);        return sieve(n))    pre  n >= 2    post         RESULT <=> not (exists p in set {2, ..., n - 1} & n mod p = 0);        createSieve : nat1 ==> ()    createSieve(size) ==        (dcl newSieve:seq of bool := [true | i in set {1, ..., size}];        (dcl n:nat1 := 2;        newSieve(1) := false;        while n  * n <= size        do            (if newSieve(n) then for m = n  * 2 to  size by  n do newSieve(m) := false;            n := n + 1));        sieve := newSieve)    pre  size >= 2    post         len sieve = size        and (forall n in set {2, ..., size} &                sieve(n) <=> not (exists p in set {2, ..., n - 1} & n mod p = 0));traces    Singles:        let n in set {2, ..., 50} in isPrime(n);        Pairs:        let n1, n2 in set {2, ..., 50}        in            (isPrime(n1);            isPrime(n2));end Eratosthenesmodule UnitTestingexports alldefinitionstypes    AssertFailure :: msg : seq of char;        AssertEqualsFailure :: actual : ? expected : ? msg : seq of char;operations    assert : bool * seq of char ==> ()    assert(b, msg) == if not b then exit mk_AssertFailure(msg);        assertEquals : ? * ? * seq of char ==> ()    assertEquals(actual, expected, msg) ==        if            actual <> expected        then            exit mk_AssertEqualsFailure(actual, expected, msg);        assertApproxEquals : real * real * real * seq of char ==> ()    assertApproxEquals(actual, expected, accuracy, msg) ==        if            abs (actual - expected) > accuracy        then            exit mk_AssertEqualsFailure(actual, expected, msg);        shouldFail : (bool -> ?) * seq of char ==> ()    shouldFail(f, msg) ==        trap - with skip in let - = f(true) in assert(false, msg);end UnitTestingmodule EratosthenesTestimports    from Eratosthenes all,    from UnitTesting        operations            assert: bool * seq of char ==> () renamed assert;            assertEquals: ? * ? * seq of char ==> () renamed assertEquals;            assertApproxEquals: real * real * real * seq of char ==> ()                renamed assertApproxEquals;            shouldFail: (bool -> ?) * seq of char ==> () renamed shouldFail;exports alldefinitionsoperations    test_pre_isPrime : () ==> ()    test_pre_isPrime() ==        (shouldFail(lambda x : bool & Eratosthenes`isPrime(1), "shouldn't test 1");        Eratosthenes`isPrime(2);        Eratosthenes`isPrime(3);        Eratosthenes`isPrime(4);        Eratosthenes`isPrime(5);        skip);        test_isPrime : () ==> ()    test_isPrime() ==        (dcl numAct:nat := 0;        shouldFail(lambda x : bool & Eratosthenes`isPrime(1), "shouldn't test 1");        numAct := #act(Eratosthenes`createSieve);        assert(Eratosthenes`isPrime(2), "2 is prime");        assertEquals(#act(Eratosthenes`createSieve) - numAct, 1, "called");        numAct := #act(Eratosthenes`createSieve);        assert(Eratosthenes`isPrime(3), "3 is prime");        assertEquals(#act(Eratosthenes`createSieve) - numAct, 1, "called");        numAct := #act(Eratosthenes`createSieve);        assert(Eratosthenes`isPrime(5), "5 is prime");        assertEquals(#act(Eratosthenes`createSieve) - numAct, 1, "called");        numAct := #act(Eratosthenes`createSieve);        assert(Eratosthenes`isPrime(5), "5 is prime");        assertEquals(#act(Eratosthenes`createSieve) - numAct, 0, "not called");        numAct := #act(Eratosthenes`createSieve);        assert(not Eratosthenes`isPrime(6), "6 is not prime");        assertEquals(#act(Eratosthenes`createSieve) - numAct, 1, "called");        numAct := #act(Eratosthenes`createSieve);        assert(Eratosthenes`isPrime(5), "5 is prime");        assertEquals(#act(Eratosthenes`createSieve) - numAct, 0, "not called");        numAct := #act(Eratosthenes`createSieve);        skip);end EratosthenesTest