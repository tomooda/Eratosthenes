module Eratosthenesexports alldefinitionsstate Sieve of    sieve : seq of boolinit s == s = mk_Sieve([])endoperations    isPrime : nat1 ==> bool    isPrime(n) ==        (if isEven(n) then return n = 2;        let index = n div 2        in            (if index > len sieve then createSieve(n);            return sieve(index)));        createSieve : nat1 ==> ()    createSieve(size) ==        (dcl            newSieve:seq of bool := [true | i in set {1, ..., size div 2 + size mod 2 - 1}];        (dcl n:nat1 := 3;        while n  * n <= size        do            (if                newSieve(n div 2)            then                for m = n  * 3 to  size by  n  * 2 do newSieve(m div 2) := false;            n := n + 2));        sieve := newSieve);functions    isEven : nat1 -> bool    isEven(n) == n mod 2 = 0;end Eratosthenesmodule UnitTestingexports alldefinitionstypes    AssertFailure :: msg : seq of char;        AssertEqualsFailure :: actual : ? expected : ? msg : seq of char;operations    assert : bool * seq of char ==> ()    assert(b, msg) == if not b then exit mk_AssertFailure(msg);        assertEquals : ? * ? * seq of char ==> ()    assertEquals(actual, expected, msg) ==        if            actual <> expected        then            exit mk_AssertEqualsFailure(actual, expected, msg);        assertApproxEquals : real * real * real * seq of char ==> ()    assertApproxEquals(actual, expected, accuracy, msg) ==        if            abs (actual - expected) > accuracy        then            exit mk_AssertEqualsFailure(actual, expected, msg);        shouldFail : (bool -> ?) * seq of char ==> ()    shouldFail(f, msg) ==        trap - with skip in let - = f(true) in assert(false, msg);end UnitTestingmodule EratosthenesTestimports    from Eratosthenes all,    from UnitTesting        operations            assert: bool * seq of char ==> () renamed assert;            assertEquals: ? * ? * seq of char ==> () renamed assertEquals;            assertApproxEquals: real * real * real * seq of char ==> ()                renamed assertApproxEquals;            shouldFail: (bool -> ?) * seq of char ==> () renamed shouldFail;exports alldefinitionsoperations    test_isPrime : () ==> ()    test_isPrime() ==        (dcl            testPost:bool := false,            testHistory:bool := false,            result:bool,            numAct:nat := 0,            numRd:nat := 0,            numWr:nat := 0,            totalAct:nat := 0,            totalRd:nat := 0,            totalWr:nat := 0;        result := Eratosthenes`isPrime(38);        numAct := #act(Eratosthenes`createSieve) - totalAct;        totalAct := #act(Eratosthenes`createSieve);        numRd := #rd(Eratosthenes`sieve) - totalRd;        totalRd := #rd(Eratosthenes`sieve);        numWr := #wr(Eratosthenes`sieve) - totalWr;        totalWr := #wr(Eratosthenes`sieve);        if testPost then assert(not result, "38 is not prime");        if            testHistory        then            (assertEquals(numAct, 0, "not created");            assertEquals(numRd, 0, "no read");            assertEquals(numWr, 0, "no write"));        result := Eratosthenes`isPrime(37);        numAct := #act(Eratosthenes`createSieve) - totalAct;        totalAct := #act(Eratosthenes`createSieve);        numRd := #rd(Eratosthenes`sieve) - totalRd;        totalRd := #rd(Eratosthenes`sieve);        numWr := #wr(Eratosthenes`sieve) - totalWr;        totalWr := #wr(Eratosthenes`sieve);        if testPost then assert(result, "37 is prime");        if            testHistory        then            (assertEquals(numAct, 1, "created");            assertEquals(numRd, 2, "2 read");            assertEquals(numWr, 1, "1 write"));        result := Eratosthenes`isPrime(23);        numAct := #act(Eratosthenes`createSieve) - totalAct;        totalAct := #act(Eratosthenes`createSieve);        numRd := #rd(Eratosthenes`sieve) - totalRd;        totalRd := #rd(Eratosthenes`sieve);        numWr := #wr(Eratosthenes`sieve) - totalWr;        totalWr := #wr(Eratosthenes`sieve);        if testPost then assert(result, "23 is prime");        if            testHistory        then            (assertEquals(numAct, 0, "not created");            assertEquals(numRd, 2, "2 read");            assertEquals(numWr, 0, "no write"));        skip);end EratosthenesTest